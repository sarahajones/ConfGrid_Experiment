<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ConfGrid-Experiment</title>

    <!--jsPsych-->
    <script src="jspsych-6.1.0/jspsych.js"></script>
    <script src="jspsych-6.1.0/plugins/jspsych-html-keyboard-response.js"></script>
    <script src="jspsych-6.1.0/plugins/jspsych-image-button-response.js"></script>
    <script src="jspsych-6.1.0/plugins/jspsych-same-different-image.js"></script>
    <script src="jspsych-6.1.0/plugins/jspsych-image-slider-response.js"></script>
    <link href="jspsych-6.1.0/css/jspsych.css" rel="stylesheet" type="text/css">

    <!--jQuery and jQuery plugins -->
    <script src="scripts/external/jquery-3.4.1.min.js"></script>
    <script src="scripts/external/jquery-3.4.1.js"></script>
    <script src="scripts/external/jquery.mousewheel.min.js"></script>
    <script src="scripts/external/jquery.scrollify.js"></script>


    <!--custom JS: trials-->
    <script src="scripts/jspsych-PIS.js"></script>
    <script src="scripts/jspsych-consent.js"></script>
    <script src="scripts/jspsych-demographics.js"></script>

    <script src="scripts/jspsych-tutorial.js"></script>
    <script src="scripts/jspsych-splashmessage.js"></script>

    <script src="scripts/jspsych-quickfire.js"></script>
    <script src="scripts/jspsych-attention.js"></script>

    <script src="scripts/jspsych-experimentscreen.js"></script>
    <script src="scripts/jspsych-confidence.js"></script>
    <script src="scripts/jspsych-feedback.js"></script>

    <script src="scripts/jspsych-feedback-form.js"></script>
    <script src="scripts/jspsych-lastScreen.js"></script>

    <!--custom JS: helpers-->
    <script src="scripts/helper-functions.js"></script>
    <script src="scripts/box-muller.js"></script>
    <script src="scripts/gaussian.js"></script>


    <!--custom CSS-->
    <link href="CSS/styles.css" rel="stylesheet" type="text/css">
    <link href="CSS/experimentscreen.css" rel="stylesheet" type="text/css">


</head>
<body class="main">
<div id="save-error">
    <h1>Error</h1>
    <p>There was an error testing whether data from the experiment could be saved to the server.
        If you would still like to participate, please contact the study lead on Prolific and we will try to figure out the issue for you. </p>
</div>
<script>

    /* EXPERIMENT INFORMATION */
    var CUREC_studyName = 'An investigation into decision confidence and category choices';
    var CUREC_ID = 'R68879/RE001';
    var PIS_version = '1.0';
    var PIS_date = 'September 2020';
    var consent_version = '1.0';
    var consent_date = 'September 2020';

    /* PreLOAD IMAGES FOR SPEED */
    var images = [
        'images/oxford-logo.jpg' +
        'images/checkmark-black.svg' +
        'images/checkmark-white.svg' +
        'images/training_fish_native.png' +
        'images/training_fish_invasive.png'
    ];

    /* EXPERIMENT VARIABLES */
    const train_trial_number = 4 ; //amount of attention check trials, 2 of each native and invasive
    const train_number = 40; //amount of training trials before each test block
    const catch_number = 40; //amount of catches in test blocks

    //setting up size variable, x-axis, 3 groupings, small medium and large.
    const size_options = ['small', 'medium', 'large'];
    //setting up color options, y-axis,  set of 3 , red-blue-purple (will be a spectrum).
    const color_options = [ 'darkred', 'rebeccapurple', 'steelblue'];
    // define distribution types
    const distribution = ['invasive', 'native']

    //define grid boxes based on size, color, and distribution type
    const distribution_corner = [
        {name: 'box2_2', value: 400, size: size_options[1], type: distribution[1], color: color_options[1]},
        {name: 'box2_3', value: 400, size: size_options[1], type: distribution[1], color: color_options[2]},
        {name: 'box3_2', value: 600, size: size_options[2], type: distribution[1], color: color_options[1]},
        {name: 'box3_3', value: 600, size: size_options[2], type: distribution[1], color: color_options[2]}
    ];

    const distribution_L = [
        {name: 'box1_1', value: 200, size: size_options[0], type: distribution[0], color: color_options[0]},
        {name: 'box2_1', value: 400, size: size_options[1], type: distribution[0], color: color_options[0]},
        {name: 'box3_1', value: 600, size: size_options[2], type: distribution[0], color: color_options[0]},
        {name: 'box1_2', value: 200, size: size_options[0], type: distribution[0], color: color_options[1]},
        {name: 'box1_3', value: 200, size: size_options[0], type: distribution[0], color: color_options[2]}
    ];

    /*BLOCK BY BLOCK DEFINITIONS*/
    //PRE-TRAINING BLOCK
    train1_stimuli = [
        'images/training_fish_native.png',
        'images/training_fish_invasive.png'
    ];

    const deck_count = train_trial_number / train1_stimuli.length;
    train1_stimuli = shuffle_shoe(train1_stimuli, deck_count); //shuffle deck

    //GAME BLOCK 1
    //BLOCK 1 TRAINING TRIALS
    let native_fish_train1 = [];
    for (let i = 0; i <= (distribution_corner.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_corner[i].value;
        let y = distribution_corner[i].color;
        for (let j = 0; j <= (((train_number/2)/4)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_corner[i].name,
                distribution_type: "native",
                location: "corner"
            };
            native_fish_train1 = native_fish_train1.concat(new_fish)
        }
    }

    let invasive_fish_train1 = [];
    for (let i = 0; i <= (distribution_L.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_L[i].value;
        let y = distribution_L[i].color;
        for (let j = 0; j <= (((train_number/2)/5)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_L[i].name,
                distribution_type: "invasive",
                location: "L"
            };
            invasive_fish_train1 = invasive_fish_train1.concat(new_fish)
        }
    }
    let fish_train1 = shuffle(native_fish_train1.concat(invasive_fish_train1));


    //BLOCK 1 TEST TRIALS
    let native_fish_1 = [];
    for (let i = 0; i <= (distribution_corner.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_corner[i].value;
        let y = distribution_corner[i].color;
        for (let j = 0; j <= (((catch_number/2)/4)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_corner[i].name,
                distribution_type: "native",
                location: "corner"
            };
            native_fish_1 = native_fish_1.concat(new_fish)
        }
    }

    let invasive_fish_1 = [];
    for (let i = 0; i <= (distribution_L.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_L[i].value;
        let y = distribution_L[i].color;
        for (let j = 0; j <= (((catch_number/2)/5)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_L[i].name,
                distribution_type: "invasive",
                location: "L"
            };
            invasive_fish_1 = invasive_fish_1.concat(new_fish)
        }
    }
    let fish_stimuli1 = shuffle(native_fish_1.concat(invasive_fish_1));

    //GAME BLOCK 2
    //BLOCK 2 TRAINING TRIALS
    let native_fish_train2 = [];
    for (let i = 0; i <= (distribution_corner.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_corner[i].value;
        let y = distribution_corner[i].color;
        for (let j = 0; j <= (((train_number/2)/4)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_corner[i].name,
                distribution_type: "native",
                location: "corner"
            };
            native_fish_train2 = native_fish_train2.concat(new_fish)
        }
    }

    let invasive_fish_train2 = [];
    for (let i = 0; i <= (distribution_L.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_L[i].value;
        let y = distribution_L[i].color;
        for (let j = 0; j <= (((train_number/2)/5)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_L[i].name,
                distribution_type: "invasive",
                location: "L"
            };
            invasive_fish_train2 = invasive_fish_train2.concat(new_fish)
        }
    }
    let fish_train2 = shuffle(native_fish_train2.concat(invasive_fish_train2));

    //BLOCK 2 TEST TRIALS
    let native_fish_2 = [];
    for (let i = 0; i <= (distribution_corner.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_corner[i].value;
        let y = distribution_corner[i].color;
        for (let j = 0; j <= (((catch_number/2)/4)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_corner[i].name,
                distribution_type: "native",
                location: "corner"
            };
            native_fish_2 = native_fish_2.concat(new_fish)
        }
    }

    let invasive_fish_2 = [];
    for (let i = 0; i <= (distribution_L.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_L[i].value;
        let y = distribution_L[i].color;
        for (let j = 0; j <= (((catch_number/2)/5)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_L[i].name,
                distribution_type: "invasive",
                location: "L"
            };
            invasive_fish_2 = invasive_fish_2.concat(new_fish)
        }
    }
    let fish_stimuli2 = shuffle(native_fish_2.concat(invasive_fish_2));

    //GAME BLOCK 3
    //BLOCK 3 TRAINING TRIALS
    let native_fish_train3 = [];
    for (let i = 0; i <= (distribution_corner.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_corner[i].value;
        let y = distribution_corner[i].color;
        for (let j = 0; j <= (((train_number/2)/4)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_corner[i].name,
                distribution_type: "native",
                location: "corner"
            };
            native_fish_train3 = native_fish_train3.concat(new_fish)
        }
    }

    let invasive_fish_train3 = [];
    for (let i = 0; i <= (distribution_L.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_L[i].value;
        let y = distribution_L[i].color;
        for (let j = 0; j <= (((train_number/2)/5)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_L[i].name,
                distribution_type: "invasive",
                location: "L"
            };
            invasive_fish_train3 = invasive_fish_train3.concat(new_fish)
        }
    }
    let fish_train3 = shuffle(native_fish_train3.concat(invasive_fish_train3));

    //BLOCK 3 TEST TRIALS
    let native_fish_3 = [];
    for (let i = 0; i <= (distribution_corner.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_corner[i].value;
        let y = distribution_corner[i].color;
        for (let j = 0; j <= (((catch_number/2)/4)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_corner[i].name,
                distribution_type: "native",
                location: "corner"
            };
            native_fish_3 = native_fish_3.concat(new_fish)
        }
    }

    let invasive_fish_3 = [];
    for (let i = 0; i <= (distribution_L.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_L[i].value;
        let y = distribution_L[i].color;
        for (let j = 0; j <= (((catch_number/2)/5)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_L[i].name,
                distribution_type: "invasive",
                location: "L"
            };
            invasive_fish_3 = invasive_fish_3.concat(new_fish)
        }
    }
    let fish_stimuli3 = shuffle(native_fish_3.concat(invasive_fish_3));

    //GAME BLOCK 4
    //BLOCK 4 TRAINING TRIALS
    let native_fish_train4 = [];
    for (let i = 0; i <= (distribution_corner.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_corner[i].value;
        let y = distribution_corner[i].color;
        for (let j = 0; j <= (((catch_number/2)/4)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_corner[i].name,
                distribution_type: "native",
                location: "corner"
            };
            native_fish_train4 = native_fish_train4.concat(new_fish)
        }
    }

    let invasive_fish_train4 = [];
    for (let i = 0; i <= (distribution_L.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_L[i].value;
        let y = distribution_L[i].color;
        for (let j = 0; j <= (((train_number/2)/5)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_L[i].name,
                distribution_type: "invasive",
                location: "L"
            };
            invasive_fish_train4 = invasive_fish_train4.concat(new_fish)
        }
    }
    let fish_train4 = shuffle(native_fish_train4.concat(invasive_fish_train4));

    //BLOCK 4 TEST TRIALS
    let native_fish_4 = [];
    for (let i = 0; i <= (distribution_corner.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_corner[i].value;
        let y = distribution_corner[i].color;
        for (let j = 0; j <= (((catch_number/2)/4)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_corner[i].name,
                distribution_type: "native",
                location: "corner"
            };
            native_fish_4 = native_fish_4.concat(new_fish)
        }
    }

    let invasive_fish_4 = [];
    for (let i = 0; i <= (distribution_L.length-1); i++) {
        let colorVal = [];
        let val = [];
        let x = distribution_L[i].value;
        let y = distribution_L[i].color;
        for (let j = 0; j <= (((catch_number/2)/5)-1); j++) {
            if(y === "darkred"){
                val[j] = generateTestSizes(66.666, 99.999, 1);
                colorVal = colorVal.concat(val[j]*0.01)
            } else if(y === "rebeccapurple"){
                val[j] = generateTestSizes(33.333, 66.666, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            else if(y === "steelblue"){
                val[j] = generateTestSizes(0, 33.333, 1);
                colorVal = colorVal.concat(val[j]*0.01)}
            let new_fish = {
                size: generateTestSizes(x, x + 200, 1),
                color: colorVal[j],
                name: distribution_L[i].name,
                distribution_type: "invasive",
                location: "L"
            };
            invasive_fish_4 = invasive_fish_4.concat(new_fish)
        }
    }
    let fish_stimuli4 = shuffle(native_fish_4.concat(invasive_fish_4));

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /* EXPERIMENTAL PAGES */
    //splash loading screen
    var splash_1 = {
        type: "jspsych-splashmessage",
        trial_type: 'Loading',
        trial_duration: 3750,
    };

    // PIS
    var PIS = {
        type: 'jspsych-PIS',
        studyName: CUREC_studyName,
        CUREC_ID: CUREC_ID,
        version: PIS_version,
        date: PIS_date
    };
    // CONSENT
    var consent = {
        type: 'jspsych-consent',
        studyName: CUREC_studyName,
        CUREC_ID: CUREC_ID,
        version: consent_version,
        date: consent_date
    };

    //DEMOGRAPHICS
    var demographics = {
        type: 'jspsych-demographics'
    };

    /* TRAINING AND INSTRUCTION*/
    var tutorial_1 = {
        type: "jspsych-tutorial",
        tutorial_count: 1
    };
    var tutorial_2 = {
        type: "jspsych-tutorial",
        tutorial_count: 2
    };
    var tutorial_3 = {
        type: "jspsych-tutorial",
        tutorial_count: 3
    };

    /* INTRO TIMELINE*/
    const intro_timeline = [
        splash_1, //happy
        PIS, //saving?
        consent, //saving?
        splash_1, //happy
        demographics, //saving?
        splash_1, //happy
        tutorial_1, //change
        tutorial_2,
        tutorial_3,
        splash_1, //happy
    ];

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //!*PRE TRAINING*!//
    const pretrain_timeline_1 = [];

    let trial_contents = train1_stimuli.map(
        s => {
            return {
                stimulus: s,
            }
        });

    for (let i = 1; i <= train_trial_number; i++) {
        const trial_details = trial_contents.pop();
        pretrain_timeline_1.push({
            type: 'jspsych-quickfire',
            stimuli: [trial_details.stimulus],
            trial_number: i,
            choices: ['Catch', 'Return'],
            stimulus_duration: 7500,
            trial_duration: 7500,
            gap_duration: 200,
            response_ends_trial: true,
            attention_check_number: 1,
            block: 11,
            filter_fun: (x) =>
                x.trial_type === "jspsych-quickfire" && x.block === 22
        });
    }

    /* attention check using pre training */
    var attention_timeline_1 = [];

    var attention1 = {
        type: "jspsych-attention",
        attention_check_number: 1,
        filter_fun: (x) =>
            x.trial_type === "jspsych-quickfire"
    };

    attention_timeline_1 = [
        attention1
    ];
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // run pretrain again (only if the attention check is failed)
    const pretrain_timeline_2 = [];

    let trial_contents2 = train1_stimuli.map(
        s => {
            return {
                stimulus: s,
            }
        });

    for (let i = 1; i <= train_trial_number; i++) {
        const trial_details = trial_contents2.pop();
        pretrain_timeline_2.push({
            type: 'jspsych-quickfire',
            stimuli: [trial_details.stimulus],
            trial_number: i,
            choices: ['Catch', 'Return'],
            stimulus_duration: 7500,
            trial_duration: 7500,
            gap_duration: 200,
            response_ends_trial: true,
            attention_check_number: 2,
            block: 22,
            filter_fun: (x) =>
                x.trial_type === "jspsych-quickfire" && x.block === 11
        });
    }

    var attention_timeline_2 = [];
    var attention2 = {
        type: "jspsych-attention",
        attention_check_number: 2,
        filter_fun: (x) =>
            x.trial_type === "jspsych-quickfire" && x.block === 22
    };

    var tutorial_4 = {
        type: "jspsych-tutorial",
        tutorial_count: 4
    };

    attention_timeline_2 = [
        attention2,
        tutorial_4
    ];

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // TRAINING BLOCK 1 //
    const block1_train_timeline = [];

    fish_train1.forEach(s => {
        block1_train_timeline.push({
            type: "jspsych-experimentscreen",
            trial_duration: 1500,
            stimulus_duration: 1500,
            choices: ['Catch', 'Return'],
            size: s.size,
            fish_class: s.name,
            fish_color: s.color,
            distribution_info: s.location,
            distribution_name: s.distribution_type,
            confidence_trial: false,
            block: 0,
            banner_text: s.distribution_type,
            canvasSize: 1000
        })
    });

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // INTERIM 1 //
    /*Next set of instructions and splash message while loading screen*/
    var tutorial_5 = {
        type: "jspsych-tutorial",
        tutorial_count: 5
    };

    var tutorial_6 = {
        type: "jspsych-tutorial",
        tutorial_count: 6
    };

    var splash_2 = {
        type: "jspsych-splashmessage",
        trial_type: 'Next',
        trial_duration: 3750,
    };

    const interim1_timeline = [
        splash_1,
        tutorial_5,
        tutorial_6,
        splash_2
    ];

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //BLOCK1 TEST TRIALS//
    const block1_timeline = [];

    fish_stimuli1.forEach(s => {
        block1_timeline.push({
            type: "jspsych-experimentscreen",
            trial_duration: 10000,
            stimulus_duration: 3000,
            choices: ['Catch', 'Return'],
            size: s.size,
            fish_class: s.name,
            fish_color: s.color,
            distribution_info: s.location,
            distribution_name: s.distribution_type,
            confidence_trial: true,
            block: 1,
            banner_text: null,
            canvasSize: 1000
        })
    });

    //BLOCK 1 FEEDBACK//
    let feedback1_timeline = [];
    var feedback1 = {
        type: "jspsych-feedback",
        trial_type: 'first',
        filter_fun: (x) =>
            x.trial_type === "jspsych-experimentscreen" && x.block === 1
    };

    var tutorial_7 = {
        type: "jspsych-tutorial",
        tutorial_count: 7
    };

    feedback1_timeline = [
        feedback1,
        tutorial_7,
        splash_1
    ];
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //INTERIM
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // TRAINING BLOCK 2 //
    const block2_train_timeline = [];

    fish_train2.forEach(s => {
        block2_train_timeline.push({
            type: "jspsych-experimentscreen",
            trial_duration: 1500,
            stimulus_duration: 1500,
            choices: ['Catch', 'Return'],
            size: s.size,
            fish_class: s.name,
            fish_color: s.color,
            distribution_info: s.location,
            distribution_name: s.distribution_type,
            confidence_trial: false,
            block: -1,
            banner_text: s.distribution_type,
            canvasSize: 1000
        })
    });

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // INTERIM 2 //
    /*Next set of instructions and splash message while loading screen*/

    const interim2_timeline = [
        splash_1,
        splash_2
    ];

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //BLOCK2 TEST TRIALS//
    const block2_timeline = [];

    fish_stimuli2.forEach(s => {
        block2_timeline.push({
            type: "jspsych-experimentscreen",
            trial_duration: 10000,
            stimulus_duration: 3000,
            choices: ['Catch', 'Return'],
            size: s.size,
            fish_class: s.name,
            fish_color: s.color,
            distribution_info: s.location,
            distribution_name: s.distribution_type,
            confidence_trial: true,
            block: 2,
            banner_text: null,
            canvasSize: 1000
        })
    });

    //BLOCK 2 FEEDBACK//
    let feedback2_timeline = [];
    var feedback2 = {
        type: "jspsych-feedback",
        trial_type: 'second',
        filter_fun: (x) =>
            x.trial_type === "jspsych-experimentscreen" && x.block === 2
    };

    feedback2_timeline = [
        feedback2,
        tutorial_7,
        splash_1
    ];
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //INTERIM
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // TRAINING BLOCK 3 //
    const block3_train_timeline = [];

    fish_train3.forEach(s => {
        block3_train_timeline.push({
            type: "jspsych-experimentscreen",
            trial_duration: 1500,
            stimulus_duration: 1500,
            choices: ['Catch', 'Return'],
            size: s.size,
            fish_class: s.name,
            fish_color: s.color,
            distribution_info: s.location,
            distribution_name: s.distribution_type,
            confidence_trial: false,
            block: -2,
            banner_text: s.distribution_type,
            canvasSize: 1000
        })
    });

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // INTERIM 3 //

    /*Next set of instructions and splash message while loading screen*/

    const interim3_timeline = [
        splash_1,
        splash_2
    ];

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //BLOCK3 TEST TRIALS//
    const block3_timeline = [];

    fish_stimuli3.forEach(s => {
        block3_timeline.push({
            type: "jspsych-experimentscreen",
            trial_duration: 10000,
            stimulus_duration: 3000,
            choices: ['Catch', 'Return'],
            size: s.size,
            fish_class: s.name,
            fish_color: s.color,
            distribution_info: s.location,
            distribution_name: s.distribution_type,
            confidence_trial: true,
            block: 3,
            banner_text: null,
            canvasSize: 1000
        })
    });
    //BLOCK 3 FEEDBACK//
    let feedback3_timeline = [];
    var feedback3 = {
        type: "jspsych-feedback",
        trial_type: 'third',
        filter_fun: (x) =>
            x.trial_type === "jspsych-experimentscreen" && x.block === 3
    };

    feedback3_timeline = [
        feedback3,
        tutorial_7,
        splash_1
    ];
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //INTERIM
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // TRAINING BLOCK 4//
    const block4_train_timeline = [];

    fish_train4.forEach(s => {
        block4_train_timeline.push({
            type: "jspsych-experimentscreen",
            trial_duration: 1500,
            stimulus_duration: 1500,
            choices: ['Catch', 'Return'],
            size: s.size,
            fish_class: s.name,
            fish_color: s.color,
            distribution_info: s.location,
            distribution_name: s.distribution_type,
            confidence_trial: false,
            block: -3,
            banner_text: s.distribution_type,
            canvasSize: 1000
        })
    });


    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // INTERIM 4 //
    /*Next set of instructions and splash message while loading screen*/

    const interim4_timeline = [
        splash_1,
        splash_2
    ];

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //BLOCK4 TEST TRIALS//
    const block4_timeline = [];

    fish_stimuli4.forEach(s => {
        block4_timeline.push({
            type: "jspsych-experimentscreen",
            trial_duration: 10000,
            stimulus_duration: 3000,
            choices: ['Catch', 'Return'],
            size: s.size,
            fish_class: s.name,
            fish_color: s.color,
            distribution_info: s.location,
            distribution_name: s.distribution_type,
            confidence_trial: true,
            block: 4,
            banner_text: null,
            canvasSize: 1000
        })
    });

    //BLOCK 4 FEEDBACK//
    let feedback4_timeline = [];
    var feedback4 = {
        type: "jspsych-feedback",
        trial_type: 'last',
        filter_fun: (x) =>
            x.trial_type === "jspsych-experimentscreen" && x.block === 4
    };

    feedback4_timeline = [
        feedback4,
        splash_1
    ];

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /*sign off experiment*/
    var end_timeline = [];

    var splash_3 = {
        type: "jspsych-splashmessage",
        trial_type: 'Last',
        trial_duration: 3000,
    };

    var feedbackForm = {
        type: 'jspsych-feedback-form',
    };

    var end_experiment = {
        type: "jspsych-lastScreen",
    };

    end_timeline = [
        splash_3,
        feedbackForm,
        end_experiment
    ];

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /* Set up timeline and launch experiment*/

    const timeline = [
        ...intro_timeline, //happy
        ...pretrain_timeline_1, //sorted
        ...attention_timeline_1, //working
        ...pretrain_timeline_2, //sorted
        ...attention_timeline_2, //working
        ...block1_train_timeline,
        ...interim1_timeline,
        ...block1_timeline,
        ...feedback1_timeline,
        ...block2_train_timeline,
        ...interim2_timeline,
        ...block2_timeline,
        ...feedback2_timeline,
        ...block3_train_timeline,
        ...interim3_timeline,
        ...block3_timeline,
        ...feedback3_timeline,
        ...block4_train_timeline,
        ...interim4_timeline,
        ...block4_timeline,
        ...feedback4_timeline,
        ...end_timeline
    ];

    test_save()
        .then(()=>{
            /* start the experiment */
            jsPsych.init({
                timeline: timeline,
                on_trial_finish: save_csv,
                on_finish: save_csv
            });
        });

    /**
     * Save the jsPsych CSV output to the server
     */
    function save_csv() {
        if(!window.experiment_metadata) {
            // Get a user ID
            let id = jsPsych.data.getURLVariable('PROLIFIC_PID');
            if(typeof id !== "string")
                id = "ID" + (10 + Math.floor(Math.random() * 89)) +
                    "T" + Math.floor(performance.timeOrigin);

            jsPsych.data.addProperties({user_id: id});

            // Fetch all the experiment data and send it to the server
            window.experiment_metadata = {
                user_id: id,
                experiment: 'zapGrid',
                version: [0, 1, 1]
            };
        }

        const data = {
            ...window.experiment_metadata,
            csv: jsPsych.data.get().csv()
        };

        fetch(
            "savecsv.php",
            {
                method: "POST",
                body: JSON.stringify(data),
                type: 'application/json'
            }
        )
            .then(r => r.text())
            .then(b => console.log(b));
    }

    /**
     * Test the ability to save files on the server
     */
    function test_save() {
        return fetch(
            "savecsv.php",
            {
                method: "POST",
                body: JSON.stringify({user_id: "test_id"}),
                type: 'application/json'
            }
        )
            .then(r => {
                if (r.status !== 200) {
                    document.getElementById('save-error').classList.add('show');
                    throw new Error('Problem saving data');
                }
                else
                    console.log('Save data test okay!');
            });
    }

</script>
</body>
</html>